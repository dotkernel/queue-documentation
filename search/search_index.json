{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Queue Dotkernel component used to queue tasks to be processed asynchronously based on netglue/laminas-messenger A queue system is a vital part in modern web applications that enables the decoupling of certain tasks from the regular request-response cycle. This is especially useful for time-consuming and resource-intensive operations which are thus handled asynchronously by background workers on a separate system. The greatest benefit is to application responsiveness, which allows faster execution, while the heavy lifting is scheduled in the queue based on available resources. The queue system uses logs to ensure maintainability and implements retry features for reliability and stability.","title":"Home"},{"location":"#queue","text":"Dotkernel component used to queue tasks to be processed asynchronously based on netglue/laminas-messenger A queue system is a vital part in modern web applications that enables the decoupling of certain tasks from the regular request-response cycle. This is especially useful for time-consuming and resource-intensive operations which are thus handled asynchronously by background workers on a separate system. The greatest benefit is to application responsiveness, which allows faster execution, while the heavy lifting is scheduled in the queue based on available resources. The queue system uses logs to ensure maintainability and implements retry features for reliability and stability.","title":"Queue"},{"location":"v1/control-commands/","text":"Available commands and usage The commands available are: GetFailedMessagesCommand.php (failed) - returns logs with messages that failed to process (levelName:error) GetProcessedMessagesCommand.php (processed) - returns logs with messages that were successfully processed (levelName:info) GetQueuedMessagesCommand (inventory) - returns all queued messages from Redis stream 'messages' The commands can be run in two different ways: CLI To run the commands via CLI, use the following syntax: php bin/cli.php failed --start=\"yyyy-mm-dd\" --end=\"yyyy-mm-dd\" --limit=int php bin/cli.php processed --start=\"yyyy-mm-dd\" --end=\"yyyy-mm-dd\" --limit=int php bin/cli.php inventory TCP message To use commands using TCP messages, the following messages can be used: echo \"failed --start=yyyy-mm-dd --end=yyyy-mm-dd --limit=days\" | socat -t1 - TCP:host:port echo \"processed --start=yyyy-mm-dd --end=yyyy-mm-dd --limit=days\" | socat -t1 - TCP:host:port In both cases, the flags are optional. Keep in mind if both start and end are set, limit will not be applied, it's only used when one of start or end is missing. To be able to test the processed command, by default when processing the \"control\" message, it is logged as successfully processed with \"levelName\":\"info\" simulating that the message was processed successfully. To use it, run the following message: echo \"control\" | socat -t1 - TCP:host:port Using -t1 flag is not necessary but can be useful, it is used to set a timeout of n seconds for both reading and writing; after n second of inactivity, socat will terminate the connection. If the timeout is not set and the server does not respond or keep the connection open, the socat process could freeze indefinitely. echo \"inventory\" | socat -t1 - TCP:host:port","title":"Control Commands"},{"location":"v1/control-commands/#available-commands-and-usage","text":"The commands available are: GetFailedMessagesCommand.php (failed) - returns logs with messages that failed to process (levelName:error) GetProcessedMessagesCommand.php (processed) - returns logs with messages that were successfully processed (levelName:info) GetQueuedMessagesCommand (inventory) - returns all queued messages from Redis stream 'messages' The commands can be run in two different ways:","title":"Available commands and usage"},{"location":"v1/control-commands/#cli","text":"To run the commands via CLI, use the following syntax: php bin/cli.php failed --start=\"yyyy-mm-dd\" --end=\"yyyy-mm-dd\" --limit=int php bin/cli.php processed --start=\"yyyy-mm-dd\" --end=\"yyyy-mm-dd\" --limit=int php bin/cli.php inventory","title":"CLI"},{"location":"v1/control-commands/#tcp-message","text":"To use commands using TCP messages, the following messages can be used: echo \"failed --start=yyyy-mm-dd --end=yyyy-mm-dd --limit=days\" | socat -t1 - TCP:host:port echo \"processed --start=yyyy-mm-dd --end=yyyy-mm-dd --limit=days\" | socat -t1 - TCP:host:port In both cases, the flags are optional. Keep in mind if both start and end are set, limit will not be applied, it's only used when one of start or end is missing. To be able to test the processed command, by default when processing the \"control\" message, it is logged as successfully processed with \"levelName\":\"info\" simulating that the message was processed successfully. To use it, run the following message: echo \"control\" | socat -t1 - TCP:host:port Using -t1 flag is not necessary but can be useful, it is used to set a timeout of n seconds for both reading and writing; after n second of inactivity, socat will terminate the connection. If the timeout is not set and the server does not respond or keep the connection open, the socat process could freeze indefinitely. echo \"inventory\" | socat -t1 - TCP:host:port","title":"TCP message"},{"location":"v1/installation/","text":"INSTALLATION git clone git clone -b default-queue https://github.com/dotkernel/queue.git Prepare config/autoload files duplicate local.php.dist as local.php , then fill in the database credentials and set the $baseUrl duplicate log.local.dist as log.local duplicate messenger.local.php.dist as messenger.local.php duplicate swoole.local.php.dist as swoole.local.php Run Composer composer install --no-dev Create services (daemon) Edit the files from /daemon folder and set proper paths copy them in /etc/systemd/system/ sudo cp /home/dotkernel/queue/daemon\\swoole.service sudo cp /home/dotkernel/queue/daemon\\messenger.service Start the daemon sudo systemctl daemon-reload sudo systemctl enable swoole.service sudo systemctl start swoole.service sudo systemctl status swoole.service Testing the installation Send a request from your local machine echo \"Hello\" | socat -T1 - TCP:SERVER-IP:8556`","title":"Installation"},{"location":"v1/installation/#installation","text":"","title":"INSTALLATION"},{"location":"v1/installation/#git-clone","text":"git clone -b default-queue https://github.com/dotkernel/queue.git","title":"git clone"},{"location":"v1/installation/#prepare-configautoload-files","text":"duplicate local.php.dist as local.php , then fill in the database credentials and set the $baseUrl duplicate log.local.dist as log.local duplicate messenger.local.php.dist as messenger.local.php duplicate swoole.local.php.dist as swoole.local.php","title":"Prepare config/autoload files"},{"location":"v1/installation/#run-composer","text":"composer install --no-dev","title":"Run Composer"},{"location":"v1/installation/#create-services-daemon","text":"Edit the files from /daemon folder and set proper paths copy them in /etc/systemd/system/ sudo cp /home/dotkernel/queue/daemon\\swoole.service sudo cp /home/dotkernel/queue/daemon\\messenger.service","title":"Create services (daemon)"},{"location":"v1/installation/#start-the-daemon","text":"sudo systemctl daemon-reload sudo systemctl enable swoole.service sudo systemctl start swoole.service sudo systemctl status swoole.service","title":"Start the daemon"},{"location":"v1/overview/","text":"Overview Dotkernel Queue is a component based on Symfony Messenger that is used to queue asynchronous tasks. netglue/laminas-messenger is an adapter that integrates Symfony Messenger with the Laminas Service Manager container for Mezzio/Laminas applications. Some everyday operations are time-consuming and resource-intensive , so it's best if they run on separate machines, decoupled from the regular request-response cycle. Asynchronous execution performed by background workers ensures that these operations won't overload the main platform. It allows the main platform to return a response and remain responsive for new requests, while tasks with long execution times are scheduled to run later. Badges","title":"Overview"},{"location":"v1/overview/#overview","text":"Dotkernel Queue is a component based on Symfony Messenger that is used to queue asynchronous tasks. netglue/laminas-messenger is an adapter that integrates Symfony Messenger with the Laminas Service Manager container for Mezzio/Laminas applications. Some everyday operations are time-consuming and resource-intensive , so it's best if they run on separate machines, decoupled from the regular request-response cycle. Asynchronous execution performed by background workers ensures that these operations won't overload the main platform. It allows the main platform to return a response and remain responsive for new requests, while tasks with long execution times are scheduled to run later.","title":"Overview"},{"location":"v1/overview/#badges","text":"","title":"Badges"},{"location":"v1/server-setup/","text":"Server setup The below instructions are working only on AlmaLinux 9 . For other operating systems, they need to be adapted accordingly. Starting point A server with AlmaLinux 9 freshly installed, up to date and with root access. Update OS sudo dnf update -y Create a new user with sudo permissions sudo useradd dotkernel sudo passwd dotkernel sudo usermod -aG wheel dotkernel Reboot server. SSH into the server as dotkernel . Install various utilities sudo dnf install -y dnf-utils sudo dnf install zip unzip socat wget PHP sudo dnf install -y https://rpms.remirepo.net/enterprise/remi-release-9.rpm sudo dnf module enable php:remi-8.4 sudo dnf install -y php php-cli php-common php-intl Start PHP-FPM sudo systemctl start php-fpm sudo systemctl enable php-fpm Install and verify swoole sudo dnf install php-pecl-swoole6 php -i | grep swoole Valkey sudo dnf install valkey sudo systemctl enable valkey sudo systemctl start valkey sudo valkey-cli ping Valkey PHP module sudo dnf install php-pecl-redis Make sure that the module is installed. php -i | grep redis Git sudo dnf install git Composer wget https://getcomposer.org/installer -O composer-installer.php sudo chmod 777 /usr/local/bin php composer-installer.php --filename=composer --install-dir=/usr/local/bin Firewall setup To add a minimum level of security, a firewall needs to be installed and allow connections from outside only to certain ports, from certain IPs. Firewall setup is not mandatory sudo dnf install firewalld sudo systemctl enable firewalld Before starting the firewall, make sure you will not get locked outside: sudo firewall-offline-cmd --zone=public --add-port=22/tcp --permanent Then enable the firewall: sudo systemctl start firewalld By default, Swoole runs on port 8556 . You can change that in the configuration file. sudo firewall-cmd --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"YOUR_IP_ADDRESS\" port port=\"8556\" protocol=\"tcp\" accept' sudo firewall-cmd --reload NOW THE SERVER IS READY","title":"Server Setup"},{"location":"v1/server-setup/#server-setup","text":"The below instructions are working only on AlmaLinux 9 . For other operating systems, they need to be adapted accordingly.","title":"Server setup"},{"location":"v1/server-setup/#starting-point","text":"A server with AlmaLinux 9 freshly installed, up to date and with root access.","title":"Starting point"},{"location":"v1/valkey/","text":"Valkey usage Valkey is an open source (BSD) high-performance key/value datastore that supports a variety of workloads such as caching, message queues and can act as a primary database. The following commands can be run in the CLI to interact with Valkey. To enter the CLI, run: valkey-cli Utility Commands List all keys matching a pattern. KEYS * Get server information and statistics: INFO Check if the server is running: PING Delete all keys in all databases: FLUSHALL Check data type stored at a specific key (Possible types: string, list, set, zset, hash, stream): TYPE keyName Key-Value Operations Set a string key to a value: SET keyName \"keyValue\" Get the value of a key: GET keyName Delete one or more keys: DEL keyName1 keyName2 Stream Commands Read entries from a stream, sorted from oldest to newest (switch '-' and '+' to reverse order): XRANGE streamName - + Delete stream: DEL streamName Remove all stream entries while also keeping the stream key: XTRIM streamName MAXLEN 0 Delete a specific entry: XDEL streamName &lt;entryId&gt;","title":"Valkey"},{"location":"v1/valkey/#valkey-usage","text":"Valkey is an open source (BSD) high-performance key/value datastore that supports a variety of workloads such as caching, message queues and can act as a primary database. The following commands can be run in the CLI to interact with Valkey. To enter the CLI, run: valkey-cli","title":"Valkey usage"},{"location":"v1/valkey/#utility-commands","text":"List all keys matching a pattern. KEYS * Get server information and statistics: INFO Check if the server is running: PING Delete all keys in all databases: FLUSHALL Check data type stored at a specific key (Possible types: string, list, set, zset, hash, stream): TYPE keyName","title":"Utility Commands"},{"location":"v1/valkey/#key-value-operations","text":"Set a string key to a value: SET keyName \"keyValue\" Get the value of a key: GET keyName Delete one or more keys: DEL keyName1 keyName2","title":"Key-Value Operations"},{"location":"v1/valkey/#stream-commands","text":"Read entries from a stream, sorted from oldest to newest (switch '-' and '+' to reverse order): XRANGE streamName - + Delete stream: DEL streamName Remove all stream entries while also keeping the stream key: XTRIM streamName MAXLEN 0 Delete a specific entry: XDEL streamName &lt;entryId&gt;","title":"Stream Commands"},{"location":"v1/what-is-queue/","text":"Tasks Delegated to the Queue Normally, the tasks delegated to the queue: Take extended periods of time to execute and may be interrupted by PHP limitations (like the PHP max_execution_time parameter). Are external which introduces delays from authentication, awaiting responses from potentially multiple interrogations, or may even fail completely because the server is offline. Are not part of the PHP response (sending emails, processing videos). Here are some example tasks meant for the queue: Data Processing like big data analytics, scientific simulations, or mathematical computations. File Handling &amp; Media Processing like video and image processing, or compression/decompression of large files. Networking like uploading/downloading large files. Database Operations like imports/exports or migrations. System &amp; Infrastructure Tasks like OS updates, software compilation, CI pipelines. The long execution times are caused by: Data size - gigabytes, terabytes etc. Complex algorithms. Hardware limitations - CPU speed, memory, storage, network bandwidth. External dependencies - waiting on APIs or human input. How the Queue Works The queue system has an active daemon that listens for TPC connections on a specific port and stores incoming messages into Redis. This method supports a large number of requests per second without overloading. Operations are then scheduled for execution when resources are available. The order of the execution uses the FIFO (First-In, First-Out) method where the oldest request is processed first, followed by newer requests. Main Features Logging - Ensures maintainability and allows debugging. Security - The firewall allows requests only from whitelisted IPs for fast response times. Retry Mechanism - Retries failing tasks a certain number of times before removing a task from the queue. Reporting - The logs enable developers to investigate various metrics via console commands like: Queue length - How many jobs are in the to-do list. Processing time per job. Error rates - How many messages failed. Throughput - Jobs/sec processed.","title":"Understanding the Queue"},{"location":"v1/what-is-queue/#tasks-delegated-to-the-queue","text":"Normally, the tasks delegated to the queue: Take extended periods of time to execute and may be interrupted by PHP limitations (like the PHP max_execution_time parameter). Are external which introduces delays from authentication, awaiting responses from potentially multiple interrogations, or may even fail completely because the server is offline. Are not part of the PHP response (sending emails, processing videos). Here are some example tasks meant for the queue: Data Processing like big data analytics, scientific simulations, or mathematical computations. File Handling &amp; Media Processing like video and image processing, or compression/decompression of large files. Networking like uploading/downloading large files. Database Operations like imports/exports or migrations. System &amp; Infrastructure Tasks like OS updates, software compilation, CI pipelines. The long execution times are caused by: Data size - gigabytes, terabytes etc. Complex algorithms. Hardware limitations - CPU speed, memory, storage, network bandwidth. External dependencies - waiting on APIs or human input.","title":"Tasks Delegated to the Queue"},{"location":"v1/what-is-queue/#how-the-queue-works","text":"The queue system has an active daemon that listens for TPC connections on a specific port and stores incoming messages into Redis. This method supports a large number of requests per second without overloading. Operations are then scheduled for execution when resources are available. The order of the execution uses the FIFO (First-In, First-Out) method where the oldest request is processed first, followed by newer requests.","title":"How the Queue Works"},{"location":"v1/what-is-queue/#main-features","text":"Logging - Ensures maintainability and allows debugging. Security - The firewall allows requests only from whitelisted IPs for fast response times. Retry Mechanism - Retries failing tasks a certain number of times before removing a task from the queue. Reporting - The logs enable developers to investigate various metrics via console commands like: Queue length - How many jobs are in the to-do list. Processing time per job. Error rates - How many messages failed. Throughput - Jobs/sec processed.","title":"Main Features"},{"location":"v1/how-to/communication-with-queue/","text":"COMMUNICATE WITH QUEUE Communication with the Dotkernel Queue can be achieved in two different ways: procedural and object-oriented. Procedural approach The main advantage of the procedural code is its simplicity, it directly connects to the queue server, sends the prepared data, and then closes the connection. In this example, the code opens a TCP connection to localhost:8556 , checks if the connection is successful, sends data in JSON format, and closes the socket. This makes the logic easy to follow and quick to implement. The disadvantage of this approach is the difficulty of reusing and extending the code. As the complexity of the project increases by repeatedly using this approach, the code becomes more difficult to maintain and not as flexible compared to the object-oriented approach. // collect the PAYLOAD that will be sent to Dotkernel Queue $data = $anyTypeOfData; // open TCP connection to Dotkernel Queue server // replace localhost with the IP of the Dotkernel Queue server // replace 8556 with the port number $client = stream_socket_client(\"tcp://localhost:8556\", $errno, $errstr, 30); if (! $client) { // log errors error_log(\"Connection error: $errstr ($errno)\"); } else { // send the PAYLOAD to Dotkernel Queue fwrite($client, json_encode($data) . \"\\n\"); // make sure your message ends with a new line // this allows the stream to know when the message is complete // without it, the server might keep waiting, and not process what was sent fclose($client); // close connection } Object-oriented approach Using object-oriented approach, queue is accessed through dedicated classes and objects. Instead of calling functions directly, you instantiate objects that encapsulate the behavior of the queue. This approach offers reusability, maintainability, and cleaner separation of responsibilities, which is especially beneficial in larger applications. To implement this approach you need to follow a few simple steps: Step 1 NotificationSystem module Create a new directory under the Core directory with the name NotificationSystem or any other name. Inside it, create a new ConfigProvider.php , a new NotificationService.php and then copy the code below. ConfigProvider code: &lt;?php declare(strict_types=1); namespace Core\\NotificationSystem; use Core\\NotificationSystem\\Service\\NotificationService; use Dot\\DependencyInjection\\Factory\\AttributedServiceFactory; /** * @phpstan-type ConfigType array{ * dependencies: DependenciesType, * } * @phpstan-type DependenciesType array{ * factories: array&lt;class-string, class-string&gt;, * } */ class ConfigProvider { /** * @return ConfigType */ public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), ]; } /** * @return DependenciesType */ public function getDependencies(): array { return [ 'factories' =&gt; [ NotificationService::class =&gt; AttributedServiceFactory::class, ], ]; } } Service code: &lt;?php declare(strict_types=1); namespace Core\\NotificationSystem\\Service; use Core\\User\\Entity\\User; use Dot\\DependencyInjection\\Attribute\\Inject; use Laminas\\Json\\Encoder; use Socket\\Raw\\Factory; use Socket\\Raw\\Socket; class NotificationService { #[Inject( 'config.notification.server', )] public function __construct( // $config from local.php (see step 3) private readonly array $config ) { } // open TCP connection to Dotkernel Queue public function createClient(): Socket { $socketRawFactory = new Factory(); return $socketRawFactory-&gt;createClient( $this-&gt;config['protocol'] . '://' . $this-&gt;config['host'] . ':' . $this-&gt;config['port'] ); } // send the PAYLOAD to Dotkernel Queue public function send(string $message): void { $this-&gt;createClient()-&gt;write($message . $this-&gt;config['eof']); } // encode processed data protected function encodeEmailMessage(array $data): string { return Encoder::encode($data); } // process and send data // change $data type depending on what you need public function sendNewAccountNotification(mixed $data): void { $data['yourKey'] = $data; $this-&gt;send($this-&gt;encodeEmailMessage($data)); } //create your own custom methods to process data } Step 2 Install new dependencies After you have finished creating the new files, navigate to composer.json and add the new dependencies under the require key: { \"require\": { \"ext-sockets\": \"*\", \"clue/socket-raw\": \"^1.6.0\" } } Install new dependencies using: composer install Under the autoload → psr-4 key add the newly created module: \"Core\\\\NotificationSystem\\\\\": \"src/Core/src/NotificationSystem/src\" Run composer dump-autoload to regenerate Composer’s autoload files. Step 3 Configuration Navigate to config/config.php and add your new Core ConfigProvider Core\\NotificationSystem\\ConfigProvider::class . After you have added the new config provider, navigate to config/autoload/local.php and add a new config key used for server connection. NOTE: if you only have the local.php.dist file, duplicate it, and delete .dist from the copy's name. 'notification' =&gt; [ 'server' =&gt; [ 'protocol' =&gt; 'tcp', 'host' =&gt; 'IP of the Dotkernel Queue ', 'port' =&gt; 'port number', 'eof' =&gt; \"\\n\", ], ], Step 4 Service usage Navigate to your handler, inject the new service and use your custom method where needed. #[Inject( NotificationService::class )] public function __construct( protected NotificationService $notificationService ) {","title":"Communication With Queue"},{"location":"v1/how-to/communication-with-queue/#communicate-with-queue","text":"Communication with the Dotkernel Queue can be achieved in two different ways: procedural and object-oriented.","title":"COMMUNICATE WITH QUEUE"},{"location":"v1/how-to/communication-with-queue/#procedural-approach","text":"The main advantage of the procedural code is its simplicity, it directly connects to the queue server, sends the prepared data, and then closes the connection. In this example, the code opens a TCP connection to localhost:8556 , checks if the connection is successful, sends data in JSON format, and closes the socket. This makes the logic easy to follow and quick to implement. The disadvantage of this approach is the difficulty of reusing and extending the code. As the complexity of the project increases by repeatedly using this approach, the code becomes more difficult to maintain and not as flexible compared to the object-oriented approach. // collect the PAYLOAD that will be sent to Dotkernel Queue $data = $anyTypeOfData; // open TCP connection to Dotkernel Queue server // replace localhost with the IP of the Dotkernel Queue server // replace 8556 with the port number $client = stream_socket_client(\"tcp://localhost:8556\", $errno, $errstr, 30); if (! $client) { // log errors error_log(\"Connection error: $errstr ($errno)\"); } else { // send the PAYLOAD to Dotkernel Queue fwrite($client, json_encode($data) . \"\\n\"); // make sure your message ends with a new line // this allows the stream to know when the message is complete // without it, the server might keep waiting, and not process what was sent fclose($client); // close connection }","title":"Procedural approach"},{"location":"v1/how-to/communication-with-queue/#object-oriented-approach","text":"Using object-oriented approach, queue is accessed through dedicated classes and objects. Instead of calling functions directly, you instantiate objects that encapsulate the behavior of the queue. This approach offers reusability, maintainability, and cleaner separation of responsibilities, which is especially beneficial in larger applications. To implement this approach you need to follow a few simple steps:","title":"Object-oriented approach"},{"location":"v1/how-to/communication-with-queue/#step-1-notificationsystem-module","text":"Create a new directory under the Core directory with the name NotificationSystem or any other name. Inside it, create a new ConfigProvider.php , a new NotificationService.php and then copy the code below. ConfigProvider code: &lt;?php declare(strict_types=1); namespace Core\\NotificationSystem; use Core\\NotificationSystem\\Service\\NotificationService; use Dot\\DependencyInjection\\Factory\\AttributedServiceFactory; /** * @phpstan-type ConfigType array{ * dependencies: DependenciesType, * } * @phpstan-type DependenciesType array{ * factories: array&lt;class-string, class-string&gt;, * } */ class ConfigProvider { /** * @return ConfigType */ public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), ]; } /** * @return DependenciesType */ public function getDependencies(): array { return [ 'factories' =&gt; [ NotificationService::class =&gt; AttributedServiceFactory::class, ], ]; } } Service code: &lt;?php declare(strict_types=1); namespace Core\\NotificationSystem\\Service; use Core\\User\\Entity\\User; use Dot\\DependencyInjection\\Attribute\\Inject; use Laminas\\Json\\Encoder; use Socket\\Raw\\Factory; use Socket\\Raw\\Socket; class NotificationService { #[Inject( 'config.notification.server', )] public function __construct( // $config from local.php (see step 3) private readonly array $config ) { } // open TCP connection to Dotkernel Queue public function createClient(): Socket { $socketRawFactory = new Factory(); return $socketRawFactory-&gt;createClient( $this-&gt;config['protocol'] . '://' . $this-&gt;config['host'] . ':' . $this-&gt;config['port'] ); } // send the PAYLOAD to Dotkernel Queue public function send(string $message): void { $this-&gt;createClient()-&gt;write($message . $this-&gt;config['eof']); } // encode processed data protected function encodeEmailMessage(array $data): string { return Encoder::encode($data); } // process and send data // change $data type depending on what you need public function sendNewAccountNotification(mixed $data): void { $data['yourKey'] = $data; $this-&gt;send($this-&gt;encodeEmailMessage($data)); } //create your own custom methods to process data }","title":"Step 1 NotificationSystem module"},{"location":"v1/how-to/communication-with-queue/#step-2-install-new-dependencies","text":"After you have finished creating the new files, navigate to composer.json and add the new dependencies under the require key: { \"require\": { \"ext-sockets\": \"*\", \"clue/socket-raw\": \"^1.6.0\" } } Install new dependencies using: composer install Under the autoload → psr-4 key add the newly created module: \"Core\\\\NotificationSystem\\\\\": \"src/Core/src/NotificationSystem/src\" Run composer dump-autoload to regenerate Composer’s autoload files.","title":"Step 2 Install new dependencies"},{"location":"v1/how-to/communication-with-queue/#step-3-configuration","text":"Navigate to config/config.php and add your new Core ConfigProvider Core\\NotificationSystem\\ConfigProvider::class . After you have added the new config provider, navigate to config/autoload/local.php and add a new config key used for server connection. NOTE: if you only have the local.php.dist file, duplicate it, and delete .dist from the copy's name. 'notification' =&gt; [ 'server' =&gt; [ 'protocol' =&gt; 'tcp', 'host' =&gt; 'IP of the Dotkernel Queue ', 'port' =&gt; 'port number', 'eof' =&gt; \"\\n\", ], ],","title":"Step 3 Configuration"},{"location":"v1/how-to/communication-with-queue/#step-4-service-usage","text":"Navigate to your handler, inject the new service and use your custom method where needed. #[Inject( NotificationService::class )] public function __construct( protected NotificationService $notificationService ) {","title":"Step 4 Service usage"},{"location":"v1/how-to/send-emails/","text":"SEND EMAILS Using a queuing service solves problems such as server overload. For example, if a server receives a large number of requests, it tries to process them synchronously, resulting in long response times or even server crashes. A concrete example is sending emails. While a series of tasks are running on the server, a task such as sending an email is passed to a queue and run in the background so the server can move on to the next task, while the queue composes the email and sends it. Tasks are queued and processed gradually (FIFO), depending on available resources. To implement such a service, the send-email branch can be taken as a model. NOTE: The default branch 1.0 holds only the base code of Queue and provides essential features such as: Adding messages to the queue Retrieving and processing messages (FIFO) Step 1 Importing Core Importing the Core is essential for the queue to communicate with the main application logic (for this case dotkernel admin ). Whether you copy the Core folder directly or add it as a submodule, it’s important to keep the Core in sync between the main project and the queue so that all classes, services, and configurations are available for message processing. Step 2 Core dependency After adding the Core, you need to make sure all external dependencies are included in composer.json. Without them, Core functionalities (cache, mail, authentication, etc.) won’t work in the queue. { \"dotkernel/dot-cache\": \"^4.3\", \"dotkernel/dot-data-fixtures\": \"^1.4.0\", \"dotkernel/dot-errorhandler\": \"4.2.1\", \"dotkernel/dot-mail\": \"^5.3.0\", \"laminas/laminas-authentication\": \"2.18.0\", \"mezzio/mezzio-authentication-oauth2\": \"^2.11\", \"mezzio/mezzio-twigrenderer\": \"^2.17.0\", \"ramsey/uuid\": \"^4.5.0\", \"ramsey/uuid-doctrine\": \"^2.1.0\", \"roave/psr-container-doctrine\": \"^5.2.2\" } Adding Core modules under autoload → psr-4 enables automatic class loading, so you don’t have to manually require each class. { \"autoload\": { \"psr-4\": { \"Queue\\\\\": \"src/\", \"Core\\\\Admin\\\\\": \"src/Core/src/Admin/src\", \"Core\\\\App\\\\\": \"src/Core/src/App/src\", \"Core\\\\Security\\\\\": \"src/Core/src/Security/src\", \"Core\\\\Setting\\\\\": \"src/Core/src/Setting/src\", \"Core\\\\User\\\\\": \"src/Core/src/User/src\", } } } Step 3 Install new dependencies Install all new dependencies using: composer install Running composer install ensures that all packages required for Core and the queue are downloaded. This includes third-party libraries and all project-specific dependencies. Step 4 Configuration Navigate to config/config.php and add ConfigProvider::class file from all packages you installed. Mezzio\\Twig\\ConfigProvider::class, Dot\\Cache\\ConfigProvider::class, Dot\\DataFixtures\\ConfigProvider::class, Dot\\Mail\\ConfigProvider::class, // Core Core\\Admin\\ConfigProvider::class, Core\\App\\ConfigProvider::class, Core\\Security\\ConfigProvider::class, Core\\Setting\\ConfigProvider::class, Core\\User\\ConfigProvider::class, Step 5 Database connection Navigate to config/autoload/local.php and fill in the database connection details. NOTE: if you only have the local.php.dist file, duplicate it, and delete .dist from the copy's name. $databases = [ 'default' =&gt; [ 'host' =&gt; '', 'dbname' =&gt; '', 'user' =&gt; '', 'password' =&gt; '', 'port' =&gt; 3306, 'driver' =&gt; 'pdo_mysql', 'charset' =&gt; 'utf8mb4', 'collate' =&gt; 'utf8mb4_general_ci', ], ]; Step 6 Email configuration Inside your config/autoload folder create a new file named mail.global.php , copy this file content and fill in your configuration. The queue will use these settings to send emails in the background. Step 7 Data management and emails sending Once everything is installed and configured we can move on to handle the data in the queue. In the message handler for example MessageHandler , each message from the queue is processed, the email is composed, and then sent. By injecting the required services and using templates, the handler can send emails without blocking the main application, respecting FIFO and asynchronous processing. In this file you can follow a simple example of how to create and send an email using data received from the queue inside the handler.","title":"Send Emails"},{"location":"v1/how-to/send-emails/#send-emails","text":"Using a queuing service solves problems such as server overload. For example, if a server receives a large number of requests, it tries to process them synchronously, resulting in long response times or even server crashes. A concrete example is sending emails. While a series of tasks are running on the server, a task such as sending an email is passed to a queue and run in the background so the server can move on to the next task, while the queue composes the email and sends it. Tasks are queued and processed gradually (FIFO), depending on available resources. To implement such a service, the send-email branch can be taken as a model. NOTE: The default branch 1.0 holds only the base code of Queue and provides essential features such as: Adding messages to the queue Retrieving and processing messages (FIFO)","title":"SEND EMAILS"},{"location":"v1/how-to/send-emails/#step-1-importing-core","text":"Importing the Core is essential for the queue to communicate with the main application logic (for this case dotkernel admin ). Whether you copy the Core folder directly or add it as a submodule, it’s important to keep the Core in sync between the main project and the queue so that all classes, services, and configurations are available for message processing.","title":"Step 1 Importing Core"},{"location":"v1/how-to/send-emails/#step-2-core-dependency","text":"After adding the Core, you need to make sure all external dependencies are included in composer.json. Without them, Core functionalities (cache, mail, authentication, etc.) won’t work in the queue. { \"dotkernel/dot-cache\": \"^4.3\", \"dotkernel/dot-data-fixtures\": \"^1.4.0\", \"dotkernel/dot-errorhandler\": \"4.2.1\", \"dotkernel/dot-mail\": \"^5.3.0\", \"laminas/laminas-authentication\": \"2.18.0\", \"mezzio/mezzio-authentication-oauth2\": \"^2.11\", \"mezzio/mezzio-twigrenderer\": \"^2.17.0\", \"ramsey/uuid\": \"^4.5.0\", \"ramsey/uuid-doctrine\": \"^2.1.0\", \"roave/psr-container-doctrine\": \"^5.2.2\" } Adding Core modules under autoload → psr-4 enables automatic class loading, so you don’t have to manually require each class. { \"autoload\": { \"psr-4\": { \"Queue\\\\\": \"src/\", \"Core\\\\Admin\\\\\": \"src/Core/src/Admin/src\", \"Core\\\\App\\\\\": \"src/Core/src/App/src\", \"Core\\\\Security\\\\\": \"src/Core/src/Security/src\", \"Core\\\\Setting\\\\\": \"src/Core/src/Setting/src\", \"Core\\\\User\\\\\": \"src/Core/src/User/src\", } } }","title":"Step 2 Core dependency"},{"location":"v1/how-to/send-emails/#step-3-install-new-dependencies","text":"Install all new dependencies using: composer install Running composer install ensures that all packages required for Core and the queue are downloaded. This includes third-party libraries and all project-specific dependencies.","title":"Step 3 Install new dependencies"},{"location":"v1/how-to/send-emails/#step-4-configuration","text":"Navigate to config/config.php and add ConfigProvider::class file from all packages you installed. Mezzio\\Twig\\ConfigProvider::class, Dot\\Cache\\ConfigProvider::class, Dot\\DataFixtures\\ConfigProvider::class, Dot\\Mail\\ConfigProvider::class, // Core Core\\Admin\\ConfigProvider::class, Core\\App\\ConfigProvider::class, Core\\Security\\ConfigProvider::class, Core\\Setting\\ConfigProvider::class, Core\\User\\ConfigProvider::class,","title":"Step 4 Configuration"},{"location":"v1/how-to/send-emails/#step-5-database-connection","text":"Navigate to config/autoload/local.php and fill in the database connection details. NOTE: if you only have the local.php.dist file, duplicate it, and delete .dist from the copy's name. $databases = [ 'default' =&gt; [ 'host' =&gt; '', 'dbname' =&gt; '', 'user' =&gt; '', 'password' =&gt; '', 'port' =&gt; 3306, 'driver' =&gt; 'pdo_mysql', 'charset' =&gt; 'utf8mb4', 'collate' =&gt; 'utf8mb4_general_ci', ], ];","title":"Step 5 Database connection"},{"location":"v1/how-to/send-emails/#step-6-email-configuration","text":"Inside your config/autoload folder create a new file named mail.global.php , copy this file content and fill in your configuration. The queue will use these settings to send emails in the background.","title":"Step 6 Email configuration"},{"location":"v1/how-to/send-emails/#step-7-data-management-and-emails-sending","text":"Once everything is installed and configured we can move on to handle the data in the queue. In the message handler for example MessageHandler , each message from the queue is processed, the email is composed, and then sent. By injecting the required services and using templates, the handler can send emails without blocking the main application, respecting FIFO and asynchronous processing. In this file you can follow a simple example of how to create and send an email using data received from the queue inside the handler.","title":"Step 7 Data management and emails sending"}]}